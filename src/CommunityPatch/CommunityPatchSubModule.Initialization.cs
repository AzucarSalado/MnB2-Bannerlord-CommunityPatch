using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HarmonyLib;
using Sigil;
using Sigil.NonGeneric;
using TaleWorlds.CampaignSystem;
using TaleWorlds.Core;
using TaleWorlds.SaveSystem.Definition;
using static CommunityPatch.CommunityPatchSubModule;

namespace CommunityPatch {

  public partial class CommunityPatchSubModule {

    private const BindingFlags AnyDeclared = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly;

    private static readonly Type LoadCtxType = Type.GetType("TaleWorlds.SaveSystem.Load.LoadContext, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly Type SaveTypeDefType = Type.GetType("TaleWorlds.SaveSystem.Definition.TypeDefinition, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly Type SaveTypeDefBaseType = SaveTypeDefType.BaseType;

    private static readonly Type GenericSaveIdType = Type.GetType("TaleWorlds.SaveSystem.Definition.GenericSaveId, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly MethodInfo GenericSaveIdBaseId = GenericSaveIdType.GetMethod("get_BaseId", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);

    private static readonly Type SaveIdType = Type.GetType("TaleWorlds.SaveSystem.Definition.SaveId, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly MethodInfo SaveIdGetStringId = SaveIdType.GetMethod("GetStringId", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);

    private static readonly ConstructorInfo SaveTypeDefCtor = SaveTypeDefType.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] {typeof(Type), SaveIdType}, null);

    private static readonly AssemblyBuilder DynAsm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("CommunityPatchSubModuleDynamicAssembly"), AssemblyBuilderAccess.RunAndCollect);

    private static readonly ModuleBuilder DynMod = DynAsm.DefineDynamicModule("CommunityPatchSubModuleDynamicAssembly");

    private static readonly ConstructorInfo SaveIdTypeMissingQuestCtor = typeof(SaveIdTypeMissingQuest).GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly, null,
      new Type[] {typeof(string), typeof(Hero), typeof(CampaignTime), typeof(int), typeof(string)}, null);

    private static readonly Type EngineCallbacksType = Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    private static readonly Type SceneScripting = Type.GetType("ManagedCallbacks.ScriptingInterfaceOfIScene, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    private static readonly Type LibraryCallbacksType = Type.GetType("ManagedCallbacks.LibraryCallbacksGenerated, TaleWorlds.DotNet.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    private static readonly Type ObjectHeaderLoadDataType = Type.GetType("TaleWorlds.SaveSystem.Load.ObjectHeaderLoadData, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly MethodInfo TypeDefinitionGetter = ObjectHeaderLoadDataType?.GetMethod("get_TypeDefinition", AnyDeclared);

    private static readonly MethodInfo TypeDefinitionSetter = ObjectHeaderLoadDataType?.GetMethod("set_TypeDefinition", AnyDeclared);

    private static readonly MethodInfo LoadContextGetter = ObjectHeaderLoadDataType?.GetMethod("get_Context", AnyDeclared);

    private static readonly MethodInfo DefContextGetter = LoadCtxType?.GetMethod("get_DefinitionContext", AnyDeclared);

    private static readonly MethodInfo TryGetTypeDefinitionMethod = typeof(DefinitionContext).GetMethod("TryGetTypeDefinition", AnyDeclared);

    private static readonly FieldInfo SaveIdField = ObjectHeaderLoadDataType?.GetField("_saveId", AnyDeclared);

    static CommunityPatchSubModule() {
      CallStackHelpers.Init();
      // catch and record exceptions
      AppDomain.CurrentDomain.FirstChanceException += (sender, args) => {
        if (RecordFirstChanceExceptions)
          RecordedFirstChanceExceptions.AddLast(args.Exception);
      };
      AppDomain.CurrentDomain.UnhandledException += (sender, args) => {
        RecordedUnhandledExceptions.AddLast((Exception) args.ExceptionObject);
        if (args.IsTerminating)
          Diagnostics.GenerateReport();
        else
          Diagnostics.QueueGenerateReport();
      };

      try {
        Harmony.Patch(EngineCallbacksType
            .GetMethod("ScreenManager_PreTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply screen manager pre-tick exception catcher patch.");
      }

      try {
        Harmony.Patch(EngineCallbacksType
            .GetMethod("ScreenManager_Tick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply screen manager tick exception catcher patch.");
      }

      try {
        Harmony.Patch(SceneScripting
            .GetMethod("Tick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalSceneTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply scene scripting interface tick exception catcher patch.");
      }

      try {
        Harmony.Patch(EngineCallbacksType
            .GetMethod("ScriptComponentBehaviour_OnTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply script component tick exception catcher patch.");
      }

      try {
        Harmony.Patch(EngineCallbacksType
            .GetMethod("ManagedScriptHolder_TickComponents", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply script holder component tick exception catcher patch.");
      }

      try {
        Harmony.Patch(LibraryCallbacksType
            .GetMethod("Managed_ApplicationTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply application tick exception catcher patch.");
      }

      try {
        Harmony.Patch(typeof(DefinitionContext)
            .GetMethod("TryGetTypeDefinition", AnyDeclared),
          postfix: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TryGetTypeDefinitionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply application tick exception catcher patch.");
      }

      // 
    }

    private static void TryGetTypeDefinitionPatch(ref DefinitionContext __instance, ref object __result, ref object saveId) {
      if (__result != null)
        return;

    }

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalSceneTickExceptionPatch(Exception __exception, UIntPtr scenePointer, float deltaTime) {
      if (__exception == null)
        return null;

      RecordedUnhandledExceptions.AddLast(__exception);

      if (SuppressTerminalTickExceptions) {
        Diagnostics.QueueGenerateReport();
        return null;
      }

      Diagnostics.GenerateReport();

      return __exception;
    }

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalTickExceptionPatch(Exception __exception) {
      if (__exception == null)
        return null;

      RecordedUnhandledExceptions.AddLast(__exception);

      if (SuppressTerminalTickExceptions) {
        Diagnostics.QueueGenerateReport();
        return null;
      }

      Diagnostics.GenerateReport();
      return __exception;
    }

    private static void SaveIdNotResolvedReporterPatch(ref object __result, ref object ____saveId) {
      if (__result != null)
        return;

      var saveIdStr = (string) SaveIdGetStringId.Invoke(____saveId, new object[0]);

      // check call stack to figure out what type this should be
      var callerFrame = new StackFrame(2);

      ShowMessage($"Missing Save Id: {saveIdStr}");

      Error("Stack Trace: " + Environment.StackTrace);

      {
        __result = CreateMissingSaveIdQuest(____saveId, saveIdStr);
        return;
      }
    }

    private static object CreateMissingSaveIdQuest(object saveIdObj, string saveIdStr) {
      // quest
      var typeName = "SaveId_" + saveIdStr;
      var saveIdType = DynMod.GetType(typeName, false, false);
      if (saveIdType == null) {
        var tb = DynMod.DefineType(typeName, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Public, typeof(SaveIdTypeMissingQuest));
        var ctorBuilder = Emit.BuildConstructor(new Type[] {typeof(string), typeof(Hero), typeof(CampaignTime), typeof(int)}, tb, MethodAttributes.Public);
        for (ushort i = 0; i <= 4; ++i)
          ctorBuilder.LoadArgument(i);
        ctorBuilder.LoadConstant(saveIdStr);
        ctorBuilder.Call(SaveIdTypeMissingQuestCtor);
        ctorBuilder.Return();
        ctorBuilder.CreateConstructor();
        saveIdType = tb.CreateTypeInfo();
      }

      var typeDef = SaveTypeDefCtor.Invoke(new[] {saveIdType, saveIdObj});
      //Error($"Caller: {callerFrame.GetMethod().FullDescription()}");
      Error($"Save Id not resolved: {saveIdStr}");
      return typeDef;
    }

  }

}
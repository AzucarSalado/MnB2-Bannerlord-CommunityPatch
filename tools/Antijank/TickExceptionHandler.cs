using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using HarmonyLib;
using TaleWorlds.DotNet;
using TaleWorlds.Engine;

namespace Antijank {

  public class TickExceptionHandler {

    private const BindingFlags AnyDeclared = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly;

    private static readonly Type EngineCallbacksType = Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    private static readonly Type SceneScripting = Type.GetType("ManagedCallbacks.ScriptingInterfaceOfIScene, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    private static readonly Type LibraryCallbacksType = Type.GetType("ManagedCallbacks.LibraryCallbacksGenerated, TaleWorlds.DotNet.AutoGenerated, Version=1.0.0.0, Culture=neutral");

    static TickExceptionHandler() {
      try {
        Context.Harmony.Patch(EngineCallbacksType
            .GetMethod("ScreenManager_PreTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply screen manager pre-tick exception catcher patch.");
      }

      try {
        Context.Harmony.Patch(EngineCallbacksType
            .GetMethod("ScreenManager_Tick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply screen manager tick exception catcher patch.");
      }

      try {
        Context.Harmony.Patch(SceneScripting
            .GetMethod("Tick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalSceneTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply scene scripting interface tick exception catcher patch.");
      }

      try {
        Context.Harmony.Patch(EngineCallbacksType
            .GetMethod("ScriptComponentBehaviour_OnTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply script component tick exception catcher patch.");
      }

      try {
        Context.Harmony.Patch(EngineCallbacksType
            .GetMethod("ManagedScriptHolder_TickComponents", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply script holder component tick exception catcher patch.");
      }

      try {
        Context.Harmony.Patch(LibraryCallbacksType
            .GetMethod("Managed_ApplicationTick", AnyDeclared),
          finalizer: new HarmonyMethod(typeof(TickExceptionHandler).GetMethod(nameof(TerminalTickExceptionPatch), AnyDeclared))
        );
      }
      catch (Exception ex) {
        CustomDebugManager.Instance.Error(ex, "Couldn't apply application tick exception catcher patch.");
      }
    }

    public static void Init() {
    }

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalTickExceptionPatch(Exception __exception, MethodBase __originalMethod) {
      if (__exception == null)
        return null;

      // TODO: option to remember ignore

      var ex = CallStackHelpers.UnnestCommonExceptions(__exception);

      var modAsm = new StackTrace(ex, false).FindModuleFromStackTrace(out var modInfo);

      void ShowDetails()
        => MessageBox.Info(ex.ToString(), "Exception Details");

      return MessageBox.Error("Exception processing tick event.\n" +
        "Do you wish to ignore this exception and continue?\n" +
        "The game may not continue running as expected if ignored.\n" +
        $"Possible Source Mod: {modInfo?.Name}\n" +
        $"Possible Source Assembly: {modAsm?.GetName().Name}\n" +
        $"Ticker: {__originalMethod.FullDescription()}\n" +
        $"Exception: {ex.GetType().Name}: {ex.Message}",
        type: MessageBoxType.YesNo,
        help: ShowDetails) != MessageBoxResult.Yes
        ? __exception
        : null;
    }

    private static readonly MethodInfo DotNetObjectGetManagedObjectWithIdMethod = typeof(DotNetObject)
      .GetMethod("GetManagedObjectWithId", AnyDeclared);

    private static readonly MethodInfo NativeObjectGetPointerMethod = typeof(NativeObject)
      .GetMethod("get_Pointer", AnyDeclared);

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalSceneTickExceptionPatch(Exception __exception, MethodBase __originalMethod, UIntPtr scenePointer, float deltaTime) {
      if (__exception == null)
        return null;
      // TODO: option to remember ignore

      var ex = CallStackHelpers.UnnestCommonExceptions(__exception);

      var modAsm = new StackTrace(ex, false).FindModuleFromStackTrace(out var modInfo);

      void ShowDetails()
        => MessageBox.Info(ex.ToString(), "Exception Details");

      if (DotNetObjectGetManagedObjectWithIdMethod
        .Invoke(null, new object[] {scenePointer}) is ScriptComponentBehaviour behavior) {
        return MessageBox.Error("Exception processing tick event.\n" +
          "Do you wish to ignore this exception and continue?\n" +
          "The game may not continue running as expected if ignored.\n" +
          $"Possible Source Mod: {modInfo?.Name}\n" +
          $"Possible Source Assembly: {modAsm?.GetName().Name}\n" +
          "Managed Behavior:\n" +
          $" • Pointer: 0x{scenePointer.ToUInt64():X16}\n" +
          $" • Entity: {behavior?.GameEntity?.Name}\n" +
          $" • Scene: {behavior?.Scene?.GetName()}\n" +
          $" • Component: {(behavior.ScriptComponent != null ? ((UIntPtr) NativeObjectGetPointerMethod.Invoke(behavior.ScriptComponent, null)).ToUInt64() : 0):X16})\n" +
          $"Ticker: {__originalMethod.FullDescription()}\n" +
          $"Exception: {ex.GetType().Name}: {ex.Message}",
          type: MessageBoxType.YesNo,
          help: ShowDetails
        ) != MessageBoxResult.Yes
          ? __exception
          : null;
      }

      return MessageBox.Error("Exception processing tick event.\n" +
        "Do you wish to ignore this exception and continue?\n" +
        "The game may not continue running as expected if ignored.\n" +
        $"Possible Source Mod: {modInfo?.Name}\n" +
        $"Possible Source Assembly: {modAsm?.GetName().Name}\n" +
        $"Managed Behavior Pointer: 0x{scenePointer.ToUInt64():X16}\n" +
        $"Ticker: {__originalMethod.FullDescription()}\n" +
        $"Exception: {ex?.GetType().Name}: {ex?.Message}",
        type: MessageBoxType.YesNo,
        help: ShowDetails) != MessageBoxResult.Yes
        ? __exception
        : null;
    }

  }

}